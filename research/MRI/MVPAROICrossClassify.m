function res = MVPAROICrossClassify(varargin)
% MVPAROICrossClassify
% 
% Description:	perform an ROI cross-classification analysis, in which a
%				classifier is trained on data from one ROI and tested on data
%				from another. PCA (via FSL's MELODIC) is performed on each ROI's
%				dataset first, in order to establish feature spaces with the
%				same dimensionality. Cross-classification is performed for every
%				pair in the set of specified masks.
% 
% Syntax:	res = MVPAROICrossClassify(<options>)
% 
% In:
% 	<options>:
%		<+ options for MRIParseDataPaths>
%		<+ options for FSLMELODIC/fMRIROI>
%		<+ options for MVPAClassify>
%		melodic:	(true) true to perform MELODIC on the extracted ROIs before
%					classification
%		comptype:	('pca') (see FSLMELODIC)
%		dim:		(50) (see FSLMELODIC)
%		targets:	(<required>) a cell specifying the target for each sample,
%					or a cell of cells (one for each dataset)
%		chunks:		(<required>) an array specifying the chunks for each sample,
%					or a cell of arrays (one for each dataset)
%		nthread:	(1) the number of threads to use
%		force:		(true) true to force classification if the outputs already
%					exist
%		force_pre:	(false) true to force preprocessing steps if the output
%					already exists
%		silent:		(false) true to suppress status messages
% 
% Out:
% 	res	- a struct of results (see MVPAClassify)
%
% Example:
%	cMask	= {'dlpfc';'occ';'ppc'};
%	res = MVPAROICrossClassify(...
%			'dir_data'			, strDirData	, ...
%			'subject'			, cSubject		, ...
%			'mask'				, cMask			, ...
%			'targets'			, cTarget		, ...
%			'chunks'			, kChunk		, ...
%			'spatiotemporal'	, true			, ...
%			'target_blank'		, 'Blank'		, ...
%			'output_dir'		, strDirOut		, ...
%			'nthread'			, 11			  ...
%			);
% 
% Updated: 2015-03-24
% Copyright 2015 Alex Schlegel (schlegel@gmail.com).  This work is licensed
% under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported
% License.

%parse the inputs
	opt		= ParseArgs(varargin,...
				'melodic'	, true	, ...
				'targets'	, []	, ...
				'chunks'	, []	, ...
				'nthread'	, 1		, ...
				'force'		, true	, ...
				'force_pre'	, false	, ...
				'silent'	, false	  ...
				);
	
	assert(~isempty(opt.targets),'targets must be specified.');
	assert(~isempty(opt.chunks),'chunks must be specified.');
	
	opt_path	= optreplace(opt.opt_extra,...
					'require'	, {'functional','mask'}	  ...
					);
	sPath		= ParseMRIDataPaths(opt_path);

%extract the ROI data
	if opt.melodic
		opt_melodic	= optadd(sPath.opt_extra,...
						'comptype'	, 'pca'	  ...
						'dim'		, 50	  ...
						);
		opt_melodic	= optreplace(opt_melodic,...
						'path_functional'	, sPath.functional	, ...
						'path_mask'			, sPath.mask		, ...
						'nthread'			, opt.nthread		, ...
						'force'				, opt.force_pre		, ...
						'silent'			, opt.silent		  ...
						);
		
		sMELODIC		= FSLMELODIC(opt_melodic);
		cPathDataROI	= sMELODIC.path.data;
	else
		opt_roi			= optreplace(sPath.opt_extra,...
							'path_functional'	, sPath.functional	, ...
							'path_mask'			, sPath.mask		, ...
							'nthread'			, opt.nthread		, ...
							'force'				, opt.force_pre		, ...
							'silent'			, opt.silent		  ...
							);
		cPathDataROI	= fMRIROI(opt_roi);
	end

%construct every pair of ROIs
	cSession					= sPath.functional_session;
	[cPathDataROI,cMaskName]	= varfun(@(x) ForceCell(x,'level',2),cPathDataROI,sPath.mask_name);
	
	[cPathDataPair,kShake]	= cellfun(@handshakes,cPathDataROI,'uni',false);
	cNamePair				= cellfun(@(s,cm,ks) arrayfun(@(k) sprintf('%s-%s-%s',s,cm{ks(k,:)}),(1:size(ks,1))','uni',false),cSession,cMaskName,kShake,'uni',false);

%classify!
	%get a target/chunk pair for each classification
		cTarget	= ForceCell(opt.targets,'level',2);
		kChunk	= ForceCell(opt.chunks);
		
		[cPathDataPair,cTarget,kChunk]	= FillSingletonArrays(cPathDataPair,cTarget,kChunk);
		
		cTargetRep	= cellfun(@(d,t) repmat({t},[size(d,1) 1]),cPathDataPair,cTarget,'uni',false);
		kChunkRep	= cellfun(@(d,c) repmat({c},[size(d,1) 1]),cPathDataPair,kChunk,'uni',false);
	
		%flatten for MVPAClassify
			[cPathDataFlat,cTargetFlat,kChunkFlat,cNameFlat]	= varfun(@(x) cat(1,x{:}),cPathDataPair,cTargetRep,kChunkRep,cNamePair);
	
	opt_mvpa	= optadd(sPath.opt_extra,...
					'output_prefix'	, cNameFlat	, ...
					'combine'		, true		, ...
					'group_stats'	, true		  ...
					);
	bCombine	= opt_mvpa.combine;
	bGroupStats	= opt_mvpa.group_stats;
	opt_mvpa	= optreplace(opt_mvpa,...
					'matchedcrossclassify'	, true			, ...
					'match_features'		, true			, ...
					'combine'				, false			, ...
					'nthread'				, opt.nthread	, ...
					'force'					, opt.force		, ...
					'silent'				, opt.silent	  ...
					);
					
	res			= MVPAClassify(cPathDataFlat,cTargetFlat,kChunkFlat,opt_mvpa);

%post-processing
	opt_pp	= optadd(sPath.opt_extra,...
				'type'		, 'roicrossclassify'	, ...
				'silent'	, opt.silent			  ...
				);
	
	cMask		= reshape(cMaskName{1},1,[]);
	cMaskPair	= cMask(kShake{1});
	res			= MVPAROIPostProcess(res,cMaskPair,opt_pp);
